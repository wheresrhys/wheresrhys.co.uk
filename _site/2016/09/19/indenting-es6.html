<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
	<link rel="icon" href="/favicon.ico"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Wheresrhys" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Wheresrhys</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About me</a><a class="page-link" href="/projects/">Projects</a><a class="page-link" href="/speaking/">Speaking</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Indenting ES2015</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-09-19T00:00:00+01:00" itemprop="datePublished">Sep 19, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="indenting-es2015">Indenting ES2015</h1>

<p>Indentation is something all coders have a love/hate relationship with. To a point, it makes code more comprehensible, indicating which statements should be thought of as a larger whole and also pointing about where the language’s block-level features are being applied. But taken too far it can lead to a confusing mess; there’s a reason it’s called the pyramid of doom. In some cases even a couple of levels of indentation can be confusing (after scrolling down a screenfull of statements try remembering if that <code class="highlighter-rouge">}</code> closes a <code class="highlighter-rouge">for</code> loop or an <code class="highlighter-rouge">if</code>…)</p>

<p>Indentation, as implied in the last sentence, is almost invariably accompanied by the presence of a curly brace, something all C-family languages have in common. A few years ago when I contemplated learning Ruby and Coffeescript I was ambivalent to their whitespace-sensitive, curly brace free worlds. ‘It’s more expressive, closer to natural language’, screamed the advocates. ‘Its like sentences if you can even call them that without proper punctuation’, I garbled back from my <code class="highlighter-rouge">{</code> crenelated <code class="highlighter-rouge">}</code> codebase.</p>

<p>But something interesting has happened lately; javascript has belatedly begun to add new programming concepts and cross-pollinate with other languages, leading to code that looks very different.</p>

<p>First up, Promises. The pyramid of doom, easily fallen into in callback-era code, is now easier to circumvent thanks to <code class="highlighter-rouge">.then()</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myThing()
	.then(function (result) {
        // do some sync stuff first then
		return doAThingTo(result.value)
	})
	.then(function (result2) {
        // do some sync stuff first then
		return doAnotherThingTo(result2.value)
	});
</code></pre></div></div>

<p>This is far neater than a lot of similar code written using callbacks. In the code sample above I’ve used the convention we’ve adopted (though not strictly enforced) at the FT of indenting <code class="highlighter-rouge">.then()</code> calls by a single tab, which makes for very readable code. I’ve also avoided nesting <code class="highlighter-rouge">then()</code> calls (e.g. I could have had the second then directly attached to the result of <code class="highlighter-rouge">doAThingTo(result)</code>), though sometimes the nature of the procedure demands some nesting e.g.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myThing()
	.then(function (result) {
		if (result.ok) {
			return result.contents()
				.then(function (contents) {
					return contents.values
				})
		} else {
			throw 'Not ok';
		}
	})
</code></pre></div></div>

<p>It is <em>possible</em> to write the above using flatter indentation, but often it’s just easier to nest a little; the flatter your <code class="highlighter-rouge">.then()</code> tree the more you have to worry about ignoring or handling certain kinds of error in your calls to <code class="highlighter-rouge">.catch()</code>, so sometimes a bit of extra indentation is the lesser of two evils.</p>

<p>So far, so dull, but also fairly readable. Now let’s introduce another ES6 feature to make it even better - arrow functions. The first example above becomes</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myThing()
    .then(result =&gt; doAThingTo(result.value))
    .then(result2 =&gt; doAnotherThingTo(result2.value));
</code></pre></div></div>

<p>This is starting to look quite beautiful. So now for a slightly more complex example</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>this.keys()
    .then(keys =&gt;
        Promise.all(
            keys
                .map(key =&gt;
                    this.db.get(key.url)
                        .then(({expires} = {}) =&gt; ({key, expires}))
            )
        )
            .then(lookups =&gt;
                lookups
                    .sort((i1, i2) =&gt; {
                        return i1.expires &gt; i2.expires ? -1 : i1.expires &lt; i2.expires ? 1 : 0;
                    })
                    .slice(count)
                    .map(({key}) =&gt; this.delete(key))
            )
    )
</code></pre></div></div>

<p>Wait… who did what in the where, now??</p>

<p>Finally I’m getting to my point - all these ES6 goodies (and ES5 such as <code class="highlighter-rouge">.map()</code>) may help us slay the old readability dragons, but they’ve brought some dragon eggs with them, and it feels like they’re just coming to the end of incubation. I’ve found myself reading code (written by others, or by myself in the recent past), which demonstrates confidence in the language, is concise as a word and elegant as a swan in an evening dress, but lacks many of the visual cues I’m used to seeing in javascript. The above example - excluding object literals - contains only <em>a single pair of curly braces</em>, but the logic it carries out is Teotihuacan in scale, and, even though I wrote it… I find it pretty confusing to look at.</p>

<p>There are simply no established practices regarding how we format and indent code written using new ES6 features, and, as a result, there’s a danger our code will gradually become an incomprehensible mess. We have tools like eslint and lintspaces to enforce coding style on a more granular level, but these, I fear, lag behind the expressiveness of the modern language.</p>

<p>So our best hope here is to establish good conventions, and avoid code smells. Here are a few I think may be worth starting with, and the reasons why. They’re not rules I rigorously adhere to yet - I’m having way too much fun with the new language features to let trivial things like ease of comprehension or maintainability bother me - but when this ES6 world gets too much, I will return here to read the words I TOLD YOU SO!</p>

<h2 id="1-there-is-no-shame-in-being-verbose">1. There is no shame in being verbose</h2>
<p>Not a rule, but more a guiding principle. We’re often led to believe that concise code is cleaner and better, but the less you write the harder it is to be explicit about your code’s intention. If in doubt, press more keys!!</p>

<h2 id="2-always-indent-then-calls-on-a-new-line">2. Always indent <code class="highlighter-rouge">.then</code> calls on a new line</h2>
<p>As mentioned a few paragraphs above, it makes for readable Promise chains</p>

<h2 id="3-start-a-new-line-and-indent-any-array-methods-where-more-than-one-is-used-in-a-chain">3. Start a new line and indent any array methods where more than one is used in a chain</h2>
<p>Again, this makes for more readable code. The reason I don’t argue for <em>always</em> starting a new line is that often the methods will be used to apply a very basic function - e.g. extracting a property from an object - and insisting on indenting can lead to more visually-fragmented code e.g. the following almost looks like it could be a mistake, and would be clearer written on one line</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myThing.getProp.getArrayPromise(arr =&gt; arr
    .map(item =&gt; item.key)
)
</code></pre></div></div>

<h2 id="4-when-applying-array-methods-within-a-promiseall-always-indent-the-target-array-if-using-more-than-one-array-method">4. When applying array methods within a <code class="highlighter-rouge">Promise.all</code>, always indent the target array if using more than one array method</h2>

<p>This more or less follows from the last point. I would rather look at</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Promise.all(
    myArray
        .map(item =&gt; item.thing)
        .filter(thing =&gt; {
            if (thing &gt; 1) {
                return 'ham';
            } else {
                return 'egg';
            }
        })
)
</code></pre></div></div>
<p>Than</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Promise.all(myArray
    .map(item =&gt; item.thing)
    .filter(thing =&gt; {
        if (thing &gt; 1) {
            return 'ham';
        } else {
            return 'egg';
        }
    }))
</code></pre></div></div>
<p>or</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Promise.all(myArray.map(item =&gt; item.thing).filter(thing =&gt; {
    if (thing &gt; 1) {
        return 'ham';
    } else {
        return 'egg';
    }
}))
</code></pre></div></div>
<p>In ES6, parentheses often play a similar signposting role to curly braces; a lack of discipline in where they’re applied should hurt our eyes as much as</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (thing)
{
    if(otherThing) callMe()
    else {ignoreMe()}
} else if (anotherThing) {
    blahBlah()
}else{whatever()
}
</code></pre></div></div>

<h2 id="5-prefer-to-use-curly-braces-and-a-return-statement-for-complex-anonymous-arrow-functions">5. Prefer to use curly braces and a <code class="highlighter-rouge">return</code> statement for complex <em>anonymous</em> arrow functions</h2>
<p>It’s great to use e.g. <code class="highlighter-rouge">arr.map(entry =&gt; entry.name)</code>, but, as in the database lookup example above, it’s possible to return far more complex results, such as <code class="highlighter-rouge">Promise.all</code> wrapped maps of maps of arrays. In addition to the lack of <code class="highlighter-rouge">return</code> statements making it confusing work out what - if anything - is being returned, the code is complex enough to develop bugs. It will therefore require stepping into or logging while debugging. The fewer explicit statements there are in your code, the harder it is to jump in exactly where you want, so your code may need a rewrite to become debuggable. These rewrites will involve putting new curly braces in exactly the right place within a series of nested parentheses. It’s very easy to make mistakes, and it just isn’t worth this much pain to save typing a <code class="highlighter-rouge">return </code> and a <code class="highlighter-rouge">{</code> <code class="highlighter-rouge">}</code>.</p>

<h2 id="6-when-within-a-then-call-try-returning-promises-before-calling-then-on-them">6. When within a <code class="highlighter-rouge">.then()</code> call, try returning Promises before calling <code class="highlighter-rouge">.then()</code> on them</h2>
<p>This is very similar to stating ‘Avoid nesting <code class="highlighter-rouge">.then()</code> calls’, but offers a technique to help achieve this. It can be hard to spot when you’re doing unnecessary nesting, but a good question to ask is ‘Could the Promise I’m <code class="highlighter-rouge">then</code>-ing have been returned before I called <code class="highlighter-rouge">.then()</code> on it?’ By asking this question just now I spotted an unecessary nesting in the database example above which I’d previously missed despite staring at the code for days.</p>

<p>e.g.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>query()
    .then(results =&gt; {
        return Promise.all(results.map(getter))
            .then(finalCalculation)
    })
</code></pre></div></div>
<p>could be rewritten as</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>query()
    .then(results =&gt; Promise.all(results.map(getter)))
    .then(finalCalculation)
</code></pre></div></div>

<h2 id="7-declaring-named-functions-matters-as-much-as-ever">7. Declaring named functions matters as much as ever,</h2>
<p>Arrow functions and chainable methods may make manipulating data inline more concise and less cluttered, but ease of authorship of the <em>parts</em> of the program does not equate to clarity of the whole. As it’s now far easier to make the magic happen inline, it perhaps requires a little more discipline to recognise when a program is complex enough to benefit from abstracting into discrete parts. And our code can only really be self-documenting if we take it apart and give the constituent parts good names.</p>

<p>The code below achieves the same result as the database example above (ignore the sloppy use of <code class="highlighter-rouge">this</code>). Its also roughly the same number of lines as before - abstracting away the complex chains into functions means the remaining wiring can be written clearly with far less need for additional indented lines.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const decorateWithExpiry = key =&gt; {
    return this.db.get(key.url)
        .then(({expires} = {}) =&gt; ({key, expires}))
}

const deleteOldest = lookups =&gt; {
    return lookups
        .sort((i1, i2) =&gt; {
            return i1.expires &gt; i2.expires ? -1 : i1.expires &lt; i2.expires ? 1 : 0;
        })
        .slice(count)
        .map(({key}) =&gt; this.delete(key))
}

this.keys()
    .then(keys =&gt; Promise.all(keys.map(decorateWithExpiry)))
    .then(deleteOldest)
</code></pre></div></div>

<hr />

<p>Is seven points enough? I reckon so.</p>

  </div><a class="u-url" href="/2016/09/19/indenting-es6.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Wheresrhys</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wheresrhys</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wheresrhys"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wheresrhys</span></a></li><li><a href="https://www.twitter.com/wheresrhys"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wheresrhys</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>The online home of Rhys Evans, rocket from the Javascript.</p>
      </div>
    </div>

  </div>

</footer>
<canvas id="dots"></canvas>
<script>
const canvas = document.getElementById('dots');
const w = canvas.width = canvas.offsetWidth;
const h = canvas.height = canvas.offsetHeight;
const ctx = canvas.getContext('2d');

const radius = 2 + Math.ceil(Math.random() * 2);
const zoom = 1 + (Math.random() * 0.1);
const angle = (Math.PI / 180) * ((Math.random() * 4) + radius / (3 * zoom));
const origin = [
  w/4 + Math.random()*w/2,
  h/4 + Math.random()*h/2
];

let n = Math.ceil(0.4 * w * h / (radius * radius));
const dots = [];
while(n--) {
  dots.push([ Math.random()*w, Math.random()*h]);
}

const rotate = (x, y) => {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle)
  return [
    cos * (x-origin[0]) - sin * (y-origin[1]) + origin[0],
    sin * (x-origin[0]) + cos * (y-origin[1]) + origin[1]
  ];
}

const magnify = ([x, y]) => {
  return [
    ((x-origin[0]) * zoom) + origin[0],
    ((y-origin[1]) * zoom) + origin[1]
  ]
}

const drawDot = (x, y) => {
  ctx.beginPath();
  ctx.arc(x, y, radius/2, 0, 2 * Math.PI, false);
  ctx.fill();
}

ctx.fillStyle = '#eedddd';
dots.forEach(([x, y]) => {
  drawDot(x, y);
})

ctx.fillStyle = '#ddddee';
dots.forEach(([x, y]) => {
  [x, y] = magnify(rotate(x, y));
  drawDot(x, y);
})
</script>
</body>

</html>
